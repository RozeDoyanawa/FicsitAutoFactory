---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Roze.
--- DateTime: 2020-08-29 21:24
---
scriptInfo.name = "Crafting T2"
scriptInfo.network = dev

local itemManagerAddress = "429823144AEF8331B86B00943C6576F9"



local lastProcessedSplitter = nil

local busses = {
    A = {
        name = "A",
        request = function(self, item, count)
            rmessage("Send for " .. tostring(count) .. " " .. item .. " from A")
            scriptInfo.network:send(itemManagerAddress, 100, "order", item, count, self.name)
        end
    },
    --B = {
    --    name = "B",
    --    request = function(self, item, count)
    --        rmessage("Send for " .. tostring(count) .. " " .. item .. " from B")
    --        scriptInfo.network:send(itemManagerAddress, 100, "order", item, count, self.name)
    --    end
    --},
}

local splitters = createLinkedList()

function processOutputs()
    if lastProcessedSplitter == nil then
        lastProcessedSplitter = splitters.first
    end
    local j = 0
    while lastProcessedSplitter do
        processSplitterOutput(lastProcessedSplitter.value.object, lastProcessedSplitter.value.reference, lastProcessedSplitter.value.name)
        lastProcessedSplitter = lastProcessedSplitter.next
        j = j + 1
        if j == 4 then
            break
        end
    end
    return 0
end

function processSplitterOutput(self, splitter, name)
    local item = splitter:getInput()
    --print("Splitter " .. splitter.nick)
    if item then
        local itemName = item.type:getName()
        local q = self.queue.first
        if itemName == nil then
            rerror("nil itemName")
        end
        while q do
            if q.value.name == nil then
                rerror("nil q.value.name")
            end
            if q.value.name == itemName and (not name or name == q.value.bus) then -- name is only set for pullers going directly to stations, not bus -> local bus
                if splitter:canOutput(self.localOutput) and splitter:transferItem(self.localOutput) then -- check if possible to move
                    q.value.count = q.value.count - 1
                    if q.value.count == 0 then
                        q:delete()
                    end
                else
                    --print("Want but wait in splitter " .. splitter.nick)
                end
                return
            end
            q = q.next
        end
        if splitter:canOutput(self.busOutput) then -- busOutput = 1 in all current cases
            splitter:transferItem(self.busOutput)
        else
            --print("Cant output in splitter " .. splitter.nick)
        end
    else
        --print("No Item in splitter " .. splitter.nick)
    end
end

function getBus(name)
    print("GetBus(" ..name .. ")")
    if busses[name] then
        return busses[name]
    else
        local bus = {
            name = name,
            parent = nil,
            queue = createLinkedList(),
            splitter = nil,
            localOutput = 2,
            busOutput = 1,
            request = function(self, item, count)
                self.queue:push({
                    name = item,
                    count = count
                })
                if self.parent then
                    rmessage("Send to parent " .. self.parent.name)
                    self.parent:request(item, count)
                else
                    rwarning( "No parent for " .. self.name)
                end
            end
        }
        local _input = component.findComponent(name)
        if _input then
            for _,input in pairs(_input) do
                local splitter = component.proxy(input)
                local _space = explode(" ", splitter.nick)
                if _space[1] and _space[1] == name then
                    if _space[1] and _space[2] then
                        local parent = getBus(_space[2])
                        if parent then
                            bus.parent = parent
                        else
                            rerror("No parent found ".. _space[2])
                        end
                    else
                        rerror("No parent tag for splitter ".. _space[1])
                    end
                    --registerEvent(splitter, bus, function(self, evt, params, po)
                    --    processSplitterOutput(self, self.splitter)
                    --end)
                    splitters:push({
                        reference = splitter,
                        object = bus
                    })
                    bus.splitter = splitter
                    --event.listen(splitter)
                    break
                end
            end
        end
        busses[name] = bus
        return bus
    end
end


for _,storage in pairs(storages) do

    storage.topup = function(self)
        local has = self.container:getInventories()[1].ItemCount
        if self.maintain - has - self.requested > self.treshold then
            local amount = self.maintain - has - self.requested
            self.requested = self.requested + amount
            --scriptInfo.network:send(itemManagerAddress, 100, "order", self.resource, amount)
            print("Topping up with " .. tostring(amount) .. " of " .. self.resource)
            self.bus:request(self.resource, amount)
        end
    end
    storage.input = function(self)
        self.requested = self.requested - 1
    end
    storage.bus = getBus(storage.busName)
    storage.requested = 0
    storage.inputConnector = storage.container:getFactoryConnectors()[2]


    registerEvent(storage.inputConnector, storage, storage.input)
    event.listen(storage.inputConnector)
    storage:topup()
end

function topUpAll()
    for _,storage in pairs(storages) do
        storage:topup()
    end
end

local seldomCounter = 0


while true do
    local result = {event.pull(0) }
    processEvent(result)
    local status, err
    --local status, err = pcall(processEvent, result)
    if err then
        rerror("Error in processEvent; ".. tostring(err))
        error(err)
    end
    --processOutputs()
    status, err = pcall(processOutputs)
    if not status and err then
        rerror("Error in processOutputs; "..tostring(err))
        error(err)
    end
    if seldomCounter == 0 then
        status, err = pcall(topUpAll)
        if err then
            rerror("Error in topUpAll; "..tostring(err))
            error(err)
        end
        seldomCounter = 5000
    else
        seldomCounter = seldomCounter - 1
    end
end
