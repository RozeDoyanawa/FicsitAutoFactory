---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Roze.
--- DateTime: 2020-08-29 13:51
---

local dev = component.proxy(component.findComponent("User Stuff Computer Network Adapter")[1])
scriptInfo.name = "User Input"
scriptInfo.network = dev
scriptInfo.debugging = true
if dev then
    dev:open(100)
    event.listen(dev)
else
    print ("No such adapter")
end
local itemManagerAddress = "429823144AEF8331B86B00943C6576F9"

screens.init("User", 1, 1, 89, 20)
local panel = component.proxy(component.findComponent("User Panel")[1])

print("Done")

local autoCraft = false

local busses = {
    A = {
        name = "A",
    },
    B = {
        name = "B",
    }
}

screens:listen(function (panel, index, x, y, key)

end)

local factoryLight = 0
local corridorLight = 0

local lampPanels = component.findComponent("Factory Light Panel")
local lampPosts = component.findComponent("FactoryLightPoles")
local factoryLightObject = component.proxy(lampPosts[1])
local buttons = {
    FactoryFloor = {},
    Corridors = {},
}

function setGroupButtonState(group, r,g,b,a)
    for _,v in pairs(group) do
        v:setColor(r,g,b,a)
    end
end


for _,v in pairs(lampPanels) do
    local bpanel = component.proxy(v)
    local button
    button = bpanel:getModule(1, 1)
    table.insert(buttons.FactoryFloor, button)
    button:setColor(0.3,0.3,0.3,0)
    registerEvent(button, button, function(self, evt)
        if factoryLight == 1 then
            factoryLight = 2
            factoryLightObject:setGroupMode("Factory Floor", 2)
            setGroupButtonState(buttons.FactoryFloor, 0.3,0.3,1,3)
        elseif factoryLight == 2 then
            factoryLight = 0
            factoryLightObject:setGroupMode("Factory Floor", 0)
            setGroupButtonState(buttons.FactoryFloor, 0.3,0.3,0.3,0)
        else
            factoryLight = 1
            factoryLightObject:setGroupMode("Factory Floor", 1)
            setGroupButtonState(buttons.FactoryFloor, 0.3,1,0.3,3)
        end
    end)
    event.listen(button)
    button = bpanel:getModule(1, 3)
    table.insert(buttons.Corridors, button)
    button:setColor(0.3,0.3,0.3,0)
    registerEvent(button, button, function(self, evt)
        if factoryLight == 1 then
            factoryLight = 2
            factoryLightObject:setGroupMode("Corridors", 2)
            setGroupButtonState(buttons.Corridors, 0.3,0.3,1,3)
        elseif factoryLight == 2 then
            factoryLight = 0
            factoryLightObject:setGroupMode("Corridors", 0)
            setGroupButtonState(buttons.Corridors, 0.3,0.3,0.3,0)
        else
            factoryLight = 1
            factoryLightObject:setGroupMode("Corridors", 1)
            setGroupButtonState(buttons.Corridors, 0.3,1,0.3,3)
        end
    end)
    event.listen(button)
end

for _,v in pairs(lampPosts) do
    local post = component.proxy(v)
    --print("Group: " .. tostring(post:getUseGroup()) .. ", mode: ")
end
for k,v in pairs(component.proxy(lampPosts[1]):getMembers()) do
    print(tostring(k) .. " = " .. tostring(v))
end

local uiSelection = nil
local recipeIndex = 1
local recipeCount = 0
local recipes = {}
local recipeNames = {}

local UI

local TEXT_ALPHA = 0.6
local BORDER_COLOR = {0.2, 0.2, 0.2, 1}
local INACTIVE_BUTTON_COLOR = {0.3,0.3,0.3,0}
local NAVIGATOR_BUTTON_COLOR = {0.3,0.3,1,0.3}

screens:setForeground(table.unpack(BORDER_COLOR))

UI = {
    main = {
        selection = nil,
        childCount = 3,
        clearAllActions = function(self)
            UI.btnLeft:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnRight:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnUp:setColor(table.unpack(NAVIGATOR_BUTTON_COLOR))
            UI.btnDown:setColor(table.unpack(NAVIGATOR_BUTTON_COLOR))
            UI.btnValueA:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnValueB:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnValueC:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnValueD:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnPlus:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnPlusBig:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnMinus:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnMinusBig:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
        end,
        paint = function(self, UI, x, y)
            screens:setForeground(table.unpack(BORDER_COLOR))
            screens:print(0,1,                      "═══════════════════════════════════════════════════════════════════════════════════════")
            y = 2
            for k,v in pairs(self.children) do
                if v == self.selection then
                    screens:setForeground(0, 1, 0, 1)
                    screens:print(x, y, "→")
                end
                screens:setForeground(1, 1, 1, TEXT_ALPHA)
                screens:print(x + 2, y, v.caption)
                y = y + 1
            end
            screens:setForeground(table.unpack(BORDER_COLOR))
            screens:print(0,screens.cellHeight - 3, "═══════════════════════════════════════════════════════════════════════════════════════")

            y = screens.cellHeight - 2
            --x = 0
            --screens:setForeground(1, 1, 1, TEXT_ALPHA)
            --screens:print(x + 0, y, "[")
            --screens:setForeground(1, 0.5, 0.5, 1)
            --screens:print(x + 1, y, "Cancel")
            --screens:setForeground(1, 1, 1, TEXT_ALPHA)
            --screens:print(x + 7, y, "]")
            --screens:setForeground(1, 1, 1, TEXT_ALPHA)
            x = screens.cellWidth - 8
            screens:setForeground(1, 1, 1, TEXT_ALPHA)
            screens:print(x + 0, y, "[")
            screens:setForeground(0.5, 1, 0.5, 1)
            screens:print(x + 1, y, "Open")
            screens:setForeground(1, 1, 1, TEXT_ALPHA)
            screens:print(x + 5, y, "]")
        end,
        enter = function(self)
            uiSelection = self
            UI.screenA:setText("")
            UI.screenB:setText("")
            UI.screenC:setText("")
            UI.screenD:setText("")
            UI.btnValueA:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnValueB:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnValueC:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnValueD:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnPlus:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnPlusBig:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnMinus:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnMinusBig:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnLeft:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnRight:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnUp:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            UI.btnDown:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
            if not self.selection then
                self.selection = self.children[1]
            end
        end,
        onUp = function(self)
            if not self.selection then
                self.selection = self.children[1]
            else
                for i=1,self.childCount,1 do
                    if self.children[i] == self.selection then
                        if i > 1 then
                            self.selection = self.children[i - 1]
                        end
                    end
                end
            end
        end,
        onDown = function(self)
            if not self.selection then
                self.selection = self.children[1]
            else
                for i=1,self.childCount,1 do
                    if self.children[i] == self.selection then
                        if i < self.childCount then
                            self.selection = self.children[i + 1]
                        end
                    end
                end
            end
        end,
        onOK = function(self)
            print(self.selection)
            if self.selection then
                self.selection:enter()
            end
        end,
        children = {
            {
                caption = "Craft Recipe",
                selectedRecipe = 1,
                craftAmount = 1,
                selectedValue = "C",
                targets = {
                    "User", "Internal", "A", "B", "Request"
                },
                selectedTarget = 0,
                paint = function(self, UI, x, y)
                    screens:setForeground(table.unpack(BORDER_COLOR))
                    screens:print(0,1,                      "═════════════════════════════════════════════╤═════════════════════════════════════════")
                    screens:setForeground(0, 1, 0, 1)
                    local viewable = 13
                    local min = math.max(self.selectedRecipe - 6, 1)
                    local max = math.min(min + viewable, recipeCount)
                    y = 2
                    if max - min < viewable then
                        local correction = viewable - (max - min)
                        min = math.max(min - correction, 1)
                    end
                    if min > 1 then
                        screens:setForeground(1, 1, 0.6, 1)
                        screens:print(x, y,"▲")
                    end
                    if max < recipeCount then
                        screens:setForeground(1, 1, 0.6, 1)
                        screens:print(x, y + viewable,"▼")
                    end
                    for i = min,max,1 do
                        if i == self.selectedRecipe then
                            screens:setForeground(0, 1, 0, 1)
                            screens:print(x, y, "→")
                        end
                        screens:setForeground(1, 1, 1, TEXT_ALPHA)
                        screens:print(x + 2, y, recipes[i].name)
                        y = y + 1
                    end
                    screens:setForeground(table.unpack(BORDER_COLOR))
                    for i = 2,screens.cellHeight - 3,1 do
                        screens:print(45, i, "│")
                    end

                    x = 47
                    y = 2
                    local curRecipe = recipes[self.selectedRecipe]
                    screens:setForeground(1, 1, 1, 1)
                    screens:print(x, y, curRecipe.name)
                    y = y + 1
                    if self.selectedValue == "C" then
                        screens:setForeground(0.6, 0.6, 1, 1)
                        screens:print(x, y, "●")
                    end
                    screens:setForeground(1, 1, 1, TEXT_ALPHA)
                    screens:print(x + 2, y, "Amount: ")
                    screens:print(x + 12, y, lpad("", 8, "_"))
                    screens:setForeground(0.4, 0.4, 1, 1)
                    local val = tostring(self.craftAmount)
                    screens:print(x + 20 - string.len(val), y, val)
                    y = y + 1

                    if self.selectedValue == "D" then
                        screens:setForeground(0.6, 0.6, 1, 1)
                        screens:print(x, y, "●")
                    end
                    screens:setForeground(1, 1, 1, TEXT_ALPHA)
                    screens:print(x + 2, y, "Target: ")
                    local _x = x + 12
                    for i=1,4,1 do
                        local t = self.targets[i]
                        if i - 1 == self.selectedTarget then
                            screens:setForeground(1, 1, 1, TEXT_ALPHA)
                            screens:print(_x, y, "[")
                            screens:setForeground(0.4, 0.4, 1, 1)
                            screens:print(_x + 1, y, t)
                            screens:setForeground(1, 1, 1, TEXT_ALPHA)
                            screens:print(_x + string.len(t) + 1, y, "]")
                        else
                            screens:setForeground(1, 1, 1, TEXT_ALPHA)
                            screens:print(_x, y, " " .. t .. " ")
                        end
                        _x = _x + string.len(t) + 2
                    end

                    y = screens.cellHeight - 3 - 2
                    local useramount = nil
                    if curRecipe.maintain then
                        y = y - 1
                    end
                    if curRecipe.userContainer then
                        y = y - 1
                        useramount = curRecipe.userContainer:getInventories()[1].ItemCount
                    end
                    screens:setForeground(0.5, 0.5, 0.5, TEXT_ALPHA)
                    --screens:print(x, y, "In system store: " .. tostring(curRecipe.amount)); y = y + 1
                    if curRecipe.userContainer then
                        if curRecipe.userMaintain then
                            screens:print(x, y, "In user store:      ");
                            if useramount == 0 then
                                screens:setForeground(1,0.3,0.3,1)
                            elseif useramount < curRecipe.userMaintain then
                                screens:setForeground(1,1,0.5,1)
                            elseif useramount >= curRecipe.userMaintain then
                                screens:setForeground(0.4,1,0.4,1)
                            end
                            screens:print(x + 22 - 6, y, string.format("%5d", useramount))
                            screens:setForeground(0.5, 0.5, 0.5, TEXT_ALPHA)
                            screens:print(x + 22 - 1, y, ":");
                            screens:setForeground(0.6, 0.6, 1, 1)
                            screens:print(x + 22 - 6, y, string.format("%5d", curRecipe.userMaintain))
                            y = y + 1
                        else
                            screens:setForeground(0.5, 0.5, 0.5, TEXT_ALPHA)
                            screens:print(x, y, "In user store:      " ); y = y + 1
                            screens:setForeground(0.6, 0.6, 1, 1)
                            screens:print(x, y - 6, string.format("%6d", useramount))
                        end
                    end
                    if curRecipe.maintain then
                        screens:setForeground(0.5, 0.5, 0.5, TEXT_ALPHA)
                        screens:print(x, y, "Autocraft until:    " .. string.format("%6d", curRecipe.maintain)); y = y + 1
                    end
                    screens:setForeground(0.5, 0.5, 0.5, TEXT_ALPHA)
                    screens:print(x, y,     "Max craft unit:     " .. string.format("%6d", tonumber(curRecipe.maxOrder))); y = y + 1
                    screens:print(x, y,     "Craft sytem:        " .. curRecipe.system); y = y + 1

                    screens:setForeground(table.unpack(BORDER_COLOR))
                    screens:print(0,screens.cellHeight - 3, "═════════════════════════════════════════════╧═════════════════════════════════════════")

                    y = screens.cellHeight - 2
                    x = 0
                    screens:setForeground(1, 1, 1, TEXT_ALPHA)
                    screens:print(x + 0, y, "[")
                    screens:setForeground(1, 0.5, 0.5, 1)
                    screens:print(x + 1, y, "Cancel")
                    screens:setForeground(1, 1, 1, TEXT_ALPHA)
                    screens:print(x + 7, y, "]")
                    screens:setForeground(1, 1, 1, TEXT_ALPHA)
                    x = screens.cellWidth - 9
                    if not stackSize[curRecipe.name] then
                        rerror("No stack size for: " .. curRecipe.name)
                    end
                    if self.selectedTarget > 0 or curRecipe.userContainer and useramount and useramount + self.craftAmount < stackSize[curRecipe.name] * 24 then
                        screens:setForeground(1, 1, 1, TEXT_ALPHA)
                        screens:print(x + 0, y, "[")
                        screens:setForeground(0.5, 1, 0.5, 1)
                        screens:print(x + 1, y, "Craft")
                        screens:setForeground(1, 1, 1, TEXT_ALPHA)
                        screens:print(x + 6, y, "]")
                    end
                end,
                onCancel = function(self)
                    UI.main:enter()
                end,
                setValue = function(self, value)
                    local selectedColor = {0.5,0.5,1,3}
                    self.selectedValue = value
                    UI.main:clearAllActions()
                    UI.btnUp:setColor(table.unpack(NAVIGATOR_BUTTON_COLOR))
                    UI.btnDown:setColor(table.unpack(NAVIGATOR_BUTTON_COLOR))
                    if self.selectedValue == "A" then
                        UI.btnValueA:setColor(table.unpack(selectedColor))
                    elseif self.selectedValue == "B" then
                        UI.btnValueB:setColor(table.unpack(selectedColor))
                    elseif value == "C" then
                        UI.btnPlus:setColor(0.7,0.3,0.7,0)
                        UI.btnPlusBig:setColor(0.7,0.3,0.7,0)
                        UI.btnMinus:setColor(0.7,0.3,0.7,0)
                        UI.btnMinusBig:setColor(0.7,0.3,0.7,0)
                        UI.btnValueC:setColor(table.unpack(selectedColor))
                    elseif value == "D" then
                        UI.btnPlus:setColor(0.7,0.3,0.7,0)
                        UI.btnValueD:setColor(table.unpack(selectedColor))
                    end
                end,
                enter = function(self)
                    self:setValue(self.selectedValue)
                    UI.screenA:setText("")
                    UI.screenB:setText("")
                    UI.screenC:setText(string.format("%7d", self.craftAmount))
                    UI.screenD:setText(self.targets[self.selectedTarget + 1])
                    self:setValue(self.selectedValue)
                    uiSelection = self
                end,
                onUp = function(self)
                    if self.selectedRecipe > 1 then
                        self.selectedRecipe = self.selectedRecipe - 1
                    end
                end,
                onDown = function(self)
                    if self.selectedRecipe < recipeCount then
                        self.selectedRecipe = self.selectedRecipe + 1
                    end
                end,
                onMinusBig = function(self)
                    if self.selectedValue == "C" then
                        self.craftAmount = math.max(math.min(self.craftAmount - 10, 9999), 1)
                        UI.screenC:setText(string.format("%7d", self.craftAmount))
                    end
                end,
                onMinus = function(self)
                    if self.selectedValue == "C" then
                        self.craftAmount = math.max(math.min(self.craftAmount - 1, 9999), 1)
                        UI.screenC:setText(string.format("%7d", self.craftAmount))
                    end
                end,
                onPlus = function(self)
                    if self.selectedValue == "C" then
                        self.craftAmount = math.max(math.min(self.craftAmount + 1, 9999), 1)
                        UI.screenC:setText(string.format("%7d", self.craftAmount))
                    elseif self.selectedValue == "D" then
                        self.selectedTarget = (self.selectedTarget + 1) % 5
                        UI.screenD:setText(self.targets[self.selectedTarget + 1])
                    end
                end,
                onPlusBig = function(self)
                    if self.selectedValue == "C" then
                        self.craftAmount = math.max(math.min(self.craftAmount + 10, 9999), 1)
                        UI.screenC:setText(string.format("%7d", self.craftAmount))
                    end
                end,
                onValueC = function(self)
                    self:setValue("C")
                end,
                onValueD = function(self)
                    self:setValue("D")
                end,
                onOK = function(self, evt, param)
                    local curRecipe = recipes[self.selectedRecipe]
                    if self.selectedTarget == 4 then
                        scriptInfo.network:send(itemManagerAddress, 100, "orderUser", curRecipe.name, self.craftAmount)
                    elseif self.selectedTarget > 0 then
                        scriptInfo.network:send(itemManagerAddress, 100, "order", curRecipe.name, self.craftAmount, self.targets[self.selectedTarget + 1])
                    elseif curRecipe.userContainer  then
                        local useramount = curRecipe.userContainer:getInventories()[1].ItemCount
                        if useramount + self.craftAmount < stackSize[curRecipe.name] * 24 then
                            scriptInfo.network:send(itemManagerAddress, 100, "order", curRecipe.name, self.craftAmount, self.targets[self.selectedTarget + 1])
                        end
                    end
                end,
            },
            {
                caption = "Refresh storage",
                paint = function(self, UI, x, y)
                    screens:setForeground(table.unpack(BORDER_COLOR))
                    screens:print(0,1,                      "═══════════════════════════════════════════════════════════════════════════════════════")
                    screens:print(0,screens.cellHeight - 3, "═══════════════════════════════════════════════════════════════════════════════════════")
                    screens:setForeground(1, 1, 1, TEXT_ALPHA)



                    y = screens.cellHeight - 2
                    x = 0
                    screens:setForeground(1, 1, 1, TEXT_ALPHA)
                    screens:print(x + 0, y, "[")
                    screens:setForeground(1, 0.5, 0.5, 1)
                    screens:print(x + 1, y, "Cancel")
                    screens:setForeground(1, 1, 1, TEXT_ALPHA)
                    screens:print(x + 7, y, "]")
                    screens:setForeground(1, 1, 1, TEXT_ALPHA)
                end,
                enter = function(self)
                    uiSelection = self
                    UI.main:clearAllActions()
                end,
                onCancel = function(self)
                    UI.main:enter()
                end,
            },
            {

                caption = "User Storage Overview",
                visibleItems = 0,
                verticalOffset = 0,

                paint = function(self, UI, x, y)
                    screens:setForeground(table.unpack(BORDER_COLOR))
                    screens:print(0,1,                      "═══════════════════════════════════════════════════════════════════════════════════════")
                    screens:print(0,screens.cellHeight - 3, "═══════════════════════════════════════════════════════════════════════════════════════")
                    local visibleHeight = 14
                    local visibleWidth = screens.cellWidth
                    local cellWidth = 14
                    local cellHeight = 4
                    local visibleColumns = math.floor(visibleWidth / cellWidth)
                    local visibleRows = math.floor(visibleHeight / cellHeight)
                    self.visibleRows = visibleRows
                    local itemIndex = self.verticalOffset * (visibleColumns) + 1
                    local xOffset = 3
                    local yOffset = y
                    local rowMax = self.verticalOffset + visibleRows
                    self.totalRows = math.ceil(recipeCount / visibleColumns)
                    for row = self.verticalOffset,rowMax + 1,1 do
                        for column = 0,visibleColumns - 1,1 do
                            --print("row=" .. tostring(row) .. ", column=" .. tostring(column))
                            local colX = (column * cellWidth) + xOffset
                            local colY = ((row - self.verticalOffset) * cellHeight) + yOffset
                            --print("colX=" .. tostring(colX) .. ", colY=" .. tostring(colY) )
                            --screens:print(colX, colY + 1, tostring(itemIndex))
                            if colY - yOffset == 0 then
                                screens:print(colX, colY, lpad("", cellWidth - 1, "═"))
                                if true or column < visibleColumns - 1 then
                                    screens:print(colX + cellWidth - 1, colY, "╤")
                                    for _y = colY + 1,colY + cellHeight - 1,1 do
                                        screens:print(colX + cellWidth - 1, _y, "│")
                                    end
                                end
                                if xOffset > 0 and column == 0 then
                                    screens:print(colX - 1, colY, "╤")
                                    for _y = colY + 1,colY + cellHeight - 1,1 do
                                        screens:print(colX - 1, _y, "│")
                                    end
                                end
                                --screens:print(0,1,                      "═══════════════════════════════════════════════════════════════════════════════════════")
                            elseif row == rowMax + 1 then
                                screens:print(colX, colY, lpad("", cellWidth - 1, "═"))
                                screens:print(colX + cellWidth - 1, colY, "╧")
                                if xOffset > 0 and column == 0 then
                                    screens:print(colX - 1, colY, "╧")
                                end
                            else
                                screens:print(colX, colY, lpad("", cellWidth - 1, "─"))
                                for _y = colY + 1,colY + cellHeight - 1,1 do
                                    screens:print(colX + cellWidth - 1, _y, "│")
                                end
                                if column < visibleColumns - 1 then
                                    screens:print(colX + cellWidth - 1,colY,  "┼")
                                else
                                    screens:print(colX + cellWidth - 1,colY,  "┤")
                                end
                                if xOffset > 0 and column == 0 then
                                    screens:print(colX - 1, colY, "├")
                                    for _y = colY + 1,colY + cellHeight - 1,1 do
                                        screens:print(colX - 1, _y, "│")
                                    end
                                end
                            end
                            computer.skip()
                            itemIndex = itemIndex + 1
                        end
                    end
                    screens:setForeground(1, 1, 1, TEXT_ALPHA)
                    --print("visibleColumns=" .. tostring(visibleColumns) .. ", visibleRows=" .. tostring(visibleRows))
                    --print("xOffset=" .. tostring(xOffset) .. ", yOffset=" .. tostring(yOffset))
                    itemIndex = self.verticalOffset * (visibleColumns) + 1
                    xOffset = 3
                    yOffset = y + 1
                    if self.verticalOffset > 0 then
                        screens:setForeground(1, 1, 0.6, 1)
                        screens:print(x, 2,"▲")
                    end
                    if self.verticalOffset < self.totalRows - visibleRows - 1 then
                        screens:setForeground(1, 1, 0.6, 1)
                        screens:print(x, screens.cellHeight - 4,"▼")
                    end
                    for row = self.verticalOffset,self.verticalOffset + visibleRows,1 do
                        for column = 0,visibleColumns - 1,1 do
                            --print("row=" .. tostring(row) .. ", column=" .. tostring(column) .. ", itemIndex=" .. tostring(itemIndex))
                            if recipes[itemIndex] then
                                local colX = column * cellWidth + xOffset
                                local colY = (row - self.verticalOffset) * cellHeight + yOffset
                                local item = recipes[itemIndex]
                                --print("Drawing recipe " .. item.name)
                                if not item.strOffset then
                                    item.strOffset = 1
                                end
                                screens:setForeground(0.5, 0.5, 0.5, TEXT_ALPHA)
                                if string.len(item.name) < cellWidth - 1 then
                                    --print("Name lesser than cellWidth")
                                    screens:print(math.ceil(colX + (cellWidth - 1) / 2 - string.len(item.name) / 2), colY, item.name)
                                else
                                    --print ("Name longer than cellWidth")
                                    local toProcess = item.name .. "   "
                                    if item.strOffset > string.len(toProcess) then
                                        item.strOffset = 1
                                    end
                                    local result = string.sub(toProcess, item.strOffset, math.min(string.len(toProcess) + item.strOffset, cellWidth - 2 + item.strOffset))
                                    if string.len(result) < cellWidth - 1 then
                                        result = result .. string.sub( toProcess, 1, math.min(item.strOffset, cellWidth - 1 - string.len(result)))
                                    end
                                    --print("Result: " .. result)
                                    item.strOffset = item.strOffset + 1

                                    screens:print(colX, colY, result)
                                end
                                if item.userContainer then
                                    local centerX = colX + cellWidth / 2
                                    local _y = colY + 1
                                    local useramount = item.userContainer:getInventories()[1].ItemCount
                                    if item.userMaintain then
                                        if useramount == 0 then
                                            screens:setForeground(1,0.3,0.3,1)
                                        elseif useramount < item.userMaintain then
                                            screens:setForeground(1,1,0.5,1)
                                        elseif useramount >= item.userMaintain then
                                            screens:setForeground(0.4,1,0.4,1)
                                        end
                                        local val = string.format("%d", useramount)
                                        screens:print(centerX - string.len(val) - 1, _y, val)
                                        screens:setForeground(0.5, 0.5, 0.5, TEXT_ALPHA)
                                        screens:print(centerX - 1, _y, ":");
                                        screens:setForeground(0.6, 0.6, 1, 1)
                                        screens:print(centerX , _y, string.format("%d", item.userMaintain))
                                        y = y + 1
                                    else
                                        screens:setForeground(0.5, 0.5, 0.5, TEXT_ALPHA)
                                        screens:setForeground(0.6, 0.6, 1, 1)
                                        local val = string.format("%d", useramount)
                                        screens:print(centerX - math.floor(string.len(val) / 2), _y, val)
                                    end
                                end
                                if item.systemContainer then
                                    local centerX = colX + cellWidth / 2
                                    local _y = colY + 2
                                    local useramount = item.systemContainer:getInventories()[1].ItemCount
                                    if item.maintain then
                                        if useramount == 0 then
                                            screens:setForeground(1,0.3,0.3,1)
                                        elseif useramount < item.maintain then
                                            screens:setForeground(1,1,0.5,1)
                                        elseif useramount >= item.maintain then
                                            screens:setForeground(0.4,1,0.4,1)
                                        end
                                        local val = string.format("%d", useramount)
                                        screens:print(centerX - string.len(val) - 1, _y, val)
                                        screens:setForeground(0.5, 0.5, 0.5, TEXT_ALPHA)
                                        screens:print(centerX - 1, _y, ":");
                                        screens:setForeground(0.6, 0.6, 1, 1)
                                        screens:print(centerX , _y, string.format("%d", item.maintain))
                                        y = y + 1
                                    else
                                        screens:setForeground(0.5, 0.5, 0.5, TEXT_ALPHA)
                                        screens:setForeground(0.6, 0.6, 1, 1)
                                        local val = string.format("%d", useramount)
                                        screens:print(centerX - math.floor(string.len(val) / 2), _y, val)
                                    end
                                end
                            end

                            itemIndex = itemIndex + 1
                        end
                    end


                    y = screens.cellHeight - 2
                    x = 0
                    screens:setForeground(1, 1, 1, TEXT_ALPHA)
                    screens:print(x + 0, y, "[")
                    screens:setForeground(1, 0.5, 0.5, 1)
                    screens:print(x + 1, y, "Cancel")
                    screens:setForeground(1, 1, 1, TEXT_ALPHA)
                    screens:print(x + 7, y, "]")
                    screens:setForeground(1, 1, 1, TEXT_ALPHA)
                end,
                enter = function(self)
                    uiSelection = self
                    self.items = {}
                    UI.main:clearAllActions()
                    UI.btnUp:setColor(table.unpack(NAVIGATOR_BUTTON_COLOR))
                    UI.btnDown:setColor(table.unpack(NAVIGATOR_BUTTON_COLOR))
                end,
                onCancel = function(self)
                    self.items = {}
                    UI.main:enter()
                end,
                onUp = function(self)
                    if self.verticalOffset > 0 then
                        self.verticalOffset = self.verticalOffset - 1
                    end
                end,
                onDown = function(self)
                    if self.verticalOffset < self.totalRows - self.visibleRows - 1 then
                        self.verticalOffset = self.verticalOffset + 1
                    end
                end,
                seldomCounter = 1,
                timeout = 0.125
            }
        }
    }
}



function printScreen()
    local selected = uiSelection;
    screens:clear()
    screens:setForeground(1, 1, 1, 0.7)
    screens:print(0,0, "User control panel")
    --screens:print(0,1, "══════════-----------------------------------------------------------------------------")
    if uiSelection then
        uiSelection:paint(UI, 0, 1)
    end
    screens:setForeground(1, 1, 1, 0.7)
    screens:flush()
end




function UI:onCancel(evt, params)
    if uiSelection.onCancel then
        uiSelection:onCancel(evt, params)
    end
    print("onCancel(" .. evt .. ")")
end
function UI:onOK(evt, params)
    if uiSelection.onOK then
        uiSelection:onOK(evt, params)
    end
    print("onOK(" .. evt .. ")")
end
function UI:onUp(evt, params)
    if uiSelection.onUp then
        uiSelection:onUp(evt, params)
    end
    print("onUp(" .. evt .. ")")
end
function UI:onDown(evt, params)
    if uiSelection.onDown then
        uiSelection:onDown(evt, params)
    end
    print("onDown(" .. evt .. ")")
end
function UI:onLeft(evt, params)
    if uiSelection.onLeft then
        uiSelection:onLeft(evt, params)
    end
    print("onLeft(" .. evt .. ")")
end
function UI:onRight(evt, params)
    if uiSelection.onRight then
        uiSelection:onRight(evt, params)
    end
    print("onRight(" .. evt .. ")")
end
function UI:onMinusBig(evt, params)
    if uiSelection.onMinusBig then
        uiSelection:onMinusBig(evt, params)
    end
    print("onMinusBig(" .. evt .. ")")
end
function UI:onMinus(evt, params)
    if uiSelection.onMinus then
        uiSelection:onMinus(evt, params)
    end
    print("onMinus(" .. evt .. ")")
end
function UI:onPlus(evt, params)
    if uiSelection.onPlus then
        uiSelection:onPlus(evt, params)
    end
    print("onPlus(" .. evt .. ")")
end
function UI:onPlusBig(evt, params)
    if uiSelection.onPlusBig then
        uiSelection:onPlusBig(evt, params)
    end
    print("onPlusBig(" .. evt .. ")")
end
function UI:onValueA(evt, params)
    if uiSelection.onValueA then
        uiSelection:onValueA(evt, params)
    end
    print("onValueA(" .. evt .. ")")
end
function UI:onValueB(evt, params)
    if uiSelection.onValueB then
        uiSelection:onValueB(evt, params)
    end
    print("onValueB(" .. evt .. ")")
end
function UI:onValueC(evt, params)
    if uiSelection.onValueC then
        uiSelection:onValueC(evt, params)
    end
    print("onValueC(" .. evt .. ")")
end
function UI:onValueD(evt, params)
    if uiSelection.onValueD then
        uiSelection:onValueD(evt, params)
    end
    print("onValueD(" .. evt .. ")")
end



UI.btnCancel = panel:getModule(0, 3)
UI.btnCancel:setColor(0.5,0.1,0.1,0)
registerEvent(UI.btnCancel, UI, UI.onCancel)
event.listen(UI.btnCancel)

UI.btnOK = panel:getModule(10, 3)
UI.btnOK:setColor(0.1,0.5,0.1,0)
registerEvent(UI.btnOK, UI, UI.onOK)
event.listen(UI.btnOK)

UI.btnUp = panel:getModule(5, 5)
UI.btnUp:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
registerEvent(UI.btnUp, UI, UI.onUp)
event.listen(UI.btnUp)

UI.btnDown = panel:getModule(5, 1)
UI.btnDown:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
registerEvent(UI.btnDown, UI, UI.onDown)
event.listen(UI.btnDown)

UI.btnLeft = panel:getModule(3, 3)
UI.btnLeft:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
registerEvent(UI.btnLeft, UI, UI.onLeft)
event.listen(UI.btnLeft)

UI.btnRight = panel:getModule(7, 3)
UI.btnRight:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
registerEvent(UI.btnRight, UI, UI.onRight)
event.listen(UI.btnRight)

UI.btnMinusBig = panel:getModule(7, 6)
UI.btnMinusBig:setColor(0.7,0.3,0.7,0)
registerEvent(UI.btnMinusBig, UI, UI.onMinusBig)
event.listen(UI.btnMinusBig)
UI.btnMinus = panel:getModule(8, 6)
UI.btnMinus:setColor(0.7,0.3,0.7,0)
registerEvent(UI.btnMinus, UI, UI.onMinus)
event.listen(UI.btnMinus)
UI.btnPlus = panel:getModule(9, 6)
UI.btnPlus:setColor(0.7,0.3,0.7,0)
registerEvent(UI.btnPlus, UI, UI.onPlus)
event.listen(UI.btnPlus)
UI.btnPlusBig = panel:getModule(10, 6)
UI.btnPlusBig:setColor(0.7,0.3,0.7,0)
registerEvent(UI.btnPlusBig, UI, UI.onPlusBig)
event.listen(UI.btnPlusBig)

UI.btnValueA = panel:getModule(4, 10)
UI.btnValueA:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
registerEvent(UI.btnValueA, UI, UI.onValueA)
event.listen(UI.btnValueA)
UI.btnValueB = panel:getModule(4, 8)
UI.btnValueB:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
registerEvent(UI.btnValueB, UI, UI.onValueB)
event.listen(UI.btnValueB)
UI.btnValueC = panel:getModule(6, 10)
UI.btnValueC:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
registerEvent(UI.btnValueC, UI, UI.onValueC)
event.listen(UI.btnValueC)
UI.btnValueD = panel:getModule(6, 8)
UI.btnValueD:setColor(table.unpack(INACTIVE_BUTTON_COLOR))
registerEvent(UI.btnValueD, UI, UI.onValueD)
event.listen(UI.btnValueD)






local defaultTextSize = 100
local defaultMonospace = true
UI.screenA = panel:getModule(0, 10)
UI.screenA:setSize(defaultTextSize)
UI.screenA:setMonospace(defaultMonospace)
UI.screenB = panel:getModule(0, 8)
UI.screenB:setSize(defaultTextSize)
UI.screenB:setMonospace(defaultMonospace)
UI.screenC = panel:getModule(10, 10)
UI.screenC:setSize(defaultTextSize)
UI.screenC:setMonospace(defaultMonospace)
UI.screenD = panel:getModule(10, 8)
UI.screenD:setSize(defaultTextSize)
UI.screenD:setMonospace(defaultMonospace)

UI.main:enter()
UI.main.children[3]:enter()






networkHandler(100, function(self, address, parameters, parameterOffset)  -- Initiate handler for port 100
    local msg = parameters[parameterOffset] -- extract message identifier
    --print(msg)
    if msg and self.subhandlers[msg] then  -- if msg is not nil and we have a subhandler for it
        local handler = self.subhandlers[msg] -- put subhandler into local variable for convenience
        handler(address, parameters, parameterOffset + 1) -- call subhandler
    elseif not msg then -- no handler or nil message
        print ("No message identifier defined")
    else
        print ("No handler for " .. parameters[parameterOffset])
    end
end, { -- table of message handlers
    item = function(address, parameters, po)
        local requestID = parameters[po]
        local itemName = parameters[po + 1]
        --print ("data: " .. parameters[po + 2])
        local data = explode("|", parameters[po + 2])
        local item = {
            name = itemName,
        }
        for _,_s in pairs(data) do
            --print(_s)
            local _i = explode("#", _s)
            if _i[1] and _i[2] then
                --print("K: " .. _i[1] .. ", V:" .. _i[2])
                if _i[1] == "userContainer" or _i[1] == "systemContainer" then
                    item[_i[1]] = component.proxy(_i[2])
                elseif (_i[3] and _i[3] == "i") or  _i[1] == "userMaintain" or _i[1] == "maintain" then
                    item[_i[1]] = tonumber(_i[2])
                else
                    item[_i[1]] = _i[2]
                end
            end
        end
        --print("Received: " .. itemName)
        recipeCount = recipeCount + 1
        table.insert(recipes, item)
        scriptInfo.network:send(address, 100, "nextItem", requestID)
    end,
    itemListingEnded = function(address, parameters, po)
        print("Listing ended")
        table.sort(recipes, function(a, b)
            return a.name < b.name
        end)
    end
})



local lightController = component.proxy("F973009045A0A8746F34A5A842CE9DC9")

for _,m in pairs(lightController:getMembers()) do
    print(m)
end

scriptInfo.network:send(itemManagerAddress, 100, "enumItems")



local seldomCounter = 0
local nilCounter = 0
local timeout = 1

while true do
    local result = {event.pull(timeout) }
    local status, err
    if result[1] then
        timeout = 0
        nilCounter = 0
        --print("Timeout reset")
    elseif nilCounter == 1000 then
        if uiSelection and uiSelection.timeout then
            timeout = uiSelection.timeout
        else
            timeout = 1
        end
        --print("Slow Timeout")
    else
        nilCounter = nilCounter + 1
    end
    --processEvent(result)
    status, err = pcall(processEvent, result)
    if not status and err then
        rerror("Error in processEvent; ".. tostring(err))
        error(err)
    end
    if timeout > 0 or seldomCounter <= 0 then
        printScreen()
        --status, err = pcall(printScreen)
        if not status and err then
            rerror("Error in print; ".. tostring(err))
            error(err)
        end
        if uiSelection and uiSelection.seldomCounter then
            seldomCounter = uiSelection.seldomCounter
        else
            seldomCounter = 1000
        end
    else
        seldomCounter = seldomCounter - 1
    end
end